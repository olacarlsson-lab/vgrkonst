<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vgrkonst</title>
  <meta name="theme-color" content="#ffffff" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" sizes="192x192" href="icon-192.png" />
  <link rel="icon" sizes="512x512" href="icon-512.png" />
  <style>
    :root { --toolbar-h: 56px; --gap: 8px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { display: flex; flex-direction: column; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header {
      height: var(--toolbar-h);
      display: flex; align-items: center; gap: var(--gap);
      padding: 8px 10px; border-bottom: 1px solid #e5e7eb; background: #fafafa;
      position: sticky; top: 0; z-index: 10;
    }
    header .grow { flex: 1; }
    button, input, label { font: inherit; }
    button {
      padding: 6px 10px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;
    }
    button:disabled { opacity: .45; cursor: not-allowed; }
    #wrap { flex: 1; min-height: 0; }
    canvas { display: block; width: 100%; height: calc(100vh - var(--toolbar-h)); touch-action: none; background: white; }
    .seg { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; }
    .seg input[type="range"] { width: 140px; }
  </style>
</head>
<body>
  <header>
    <div class="seg" title="Färg">
      <label for="color">Färg</label>
      <input id="color" type="color" value="#1f2937" />
    </div>
    <div class="seg" title="Penselstorlek">
      <label for="size">Storlek</label>
      <input id="size" type="range" min="1" max="60" value="8" />
      <span id="sizeVal">8</span>
    </div>
    <div class="grow"></div>
    <button id="undoBtn" type="button" disabled>Ångra</button>
    <button id="redoBtn" type="button" disabled>Gör om</button>
    <button id="clearBtn" type="button">Rensa</button>
    <button id="saveBtn" type="button">Spara PNG</button>
  </header>

  <div id="wrap">
    <canvas id="board"></canvas>
  </div>

  <script>
    // ====== Canvas setup med HiDPI-stöd ======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const toolbarH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--toolbar-h'));
    function resizeCanvas(preserve = true) {
      const dpr = window.devicePixelRatio || 1;
      const cssW = window.innerWidth;
      const cssH = Math.max(0, window.innerHeight - toolbarH);

      let snapshotImg = null;
      if (preserve) {
        snapshotImg = new Image();
        try { snapshotImg.src = canvas.toDataURL('image/png'); } catch {}
      }

      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.max(1, Math.floor(cssW * dpr));
      canvas.height = Math.max(1, Math.floor(cssH * dpr));

      // Ställ in transform så att vi kan rita i CSS-pixlar
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Återställ tidigare bild om det finns
      if (snapshotImg && snapshotImg.complete) {
        snapshotImg.onload = null;
        ctx.drawImage(snapshotImg, 0, 0, canvas.width / dpr, canvas.height / dpr);
      } else if (snapshotImg) {
        snapshotImg.onload = () => {
          ctx.drawImage(snapshotImg, 0, 0, canvas.width / dpr, canvas.height / dpr);
        };
      } else {
        // tom bakgrund
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }
    window.addEventListener('resize', () => resizeCanvas(true));
    resizeCanvas(false);

    // ====== Verktygsinställningar ======
    const colorEl = document.getElementById('color');
    const sizeEl = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    function applyBrush() {
      ctx.strokeStyle = colorEl.value;
      ctx.fillStyle = colorEl.value;
      ctx.lineWidth = parseFloat(sizeEl.value);
      sizeVal.textContent = sizeEl.value;
    }
    applyBrush();
    colorEl.addEventListener('input', applyBrush);
    sizeEl.addEventListener('input', applyBrush);

    // ====== Undo/Redo-stackar ======
    const undoStack = [];
    const redoStack = [];
    const MAX_HISTORY = 80;

    function snapshot() {
      // OBS: fungerar endast om canvas INTE är tainted (inga externa bilder utan CORS)
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
    function restore(imgData) {
      // imgData skapad i backing store (DPR), så vi sätter transform till 1:1 temporärt
      const m = ctx.getTransform();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.putImageData(imgData, 0, 0);
      ctx.setTransform(m);
      updateUndoRedoButtons();
    }
    function pushUndo() {
      redoStack.length = 0;
      try {
        // spara backing store-data, inte CSS-pixlar
        const m = ctx.getTransform();
        ctx.setTransform(1,0,0,1,0,0);
        undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        ctx.setTransform(m);
        if (undoStack.length > MAX_HISTORY) undoStack.shift();
      } catch (e) {
        console.warn('Kunde inte spara historik (tainted canvas?):', e);
      }
      updateUndoRedoButtons();
    }
    function undo() {
      if (!undoStack.length) return;
      try {
        const m = ctx.getTransform();
        ctx.setTransform(1,0,0,1,0,0);
        const cur = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.setTransform(m);
        redoStack.push(cur);
        const prev = undoStack.pop();
        restore(prev);
      } catch (e) { console.warn('Kunde inte ångra:', e); }
      updateUndoRedoButtons();
    }
    function redo() {
      if (!redoStack.length) return;
      try {
        const m = ctx.getTransform();
        ctx.setTransform(1,0,0,1,0,0);
        const cur = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.setTransform(m);
        undoStack.push(cur);
        const next = redoStack.pop();
        restore(next);
      } catch (e) { console.warn('Kunde inte göra om:', e); }
      updateUndoRedoButtons();
    }
    function updateUndoRedoButtons() {
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      document.getElementById('redoBtn').disabled = redoStack.length === 0;
    }

    // ====== Ritlogik (pointer) ======
    let drawing = false;
    let lastX = 0, lastY = 0;

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      return { x, y };
    }

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);
      pushUndo(); // <-- snapshot innan förändring
      drawing = true;
      applyBrush();
      const { x, y } = getPos(e);
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.moveTo(x, y);
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      const { x, y } = getPos(e);
      const pressure = (e.pressure && e.pressure > 0) ? e.pressure : 1;
      ctx.lineWidth = parseFloat(sizeEl.value) * pressure;
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    });

    function endStroke(e) {
      if (!drawing) return;
      drawing = false;
      ctx.closePath();
      updateUndoRedoButtons();
    }
    canvas.addEventListener('pointerup', endStroke);
    canvas.addEventListener('pointercancel', endStroke);
    canvas.addEventListener('pointerleave', endStroke);

    // ====== Knappar & kortkommandon ======
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    document.getElementById('clearBtn').addEventListener('click', () => {
      pushUndo();
      const m = ctx.getTransform();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(m);
      // vit bakgrund igen (annars transparent)
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio||1), canvas.height / (window.devicePixelRatio||1));
      updateUndoRedoButtons();
    });

    document.getElementById('saveBtn').addEventListener('click', () => {
      // Spara i CSS-pixelskala (skapa en temporär canvas som inte är HiDPI)
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.width / dpr, h = canvas.height / dpr;
      const tmp = document.createElement('canvas');
      tmp.width = w; tmp.height = h;
      const tctx = tmp.getContext('2d');
      tctx.fillStyle = 'white';
      tctx.fillRect(0, 0, w, h);
      tctx.drawImage(canvas, 0, 0, w, h);
      const url = tmp.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'vgrkonst.png';
      a.click();
    });

    // Ctrl/Cmd+Z, Ctrl/Cmd+Shift+Z, Ctrl/Cmd+Y
    window.addEventListener('keydown', (e) => {
      const mod = e.ctrlKey || e.metaKey;
      if (!mod) return;
      const k = e.key.toLowerCase();
      if (k === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
      else if (k === 'y' || (k === 'z' && e.shiftKey)) { e.preventDefault(); redo(); }
    });

    // ====== PWA: registrera service worker om finns ======
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(()=>{});
    }
  </script>
</body>
</html>